TITLE: Computational Physics and Quantum Mechanical Systems
AUTHOR: Morten Hjorth-Jensen  {copyright, 1999-present|CC BY-NC} at Department of Physics, University of Oslo, Norway & Department of Physics and Astronomy and National Superconducting Cyclotron Laboratory, Michigan State University, USA
DATE: May 16-20, 2016





!split
===== Topics covered in this course =====
!bblock
This course aims at giving you an overview of important numerical methods for solving quantum mechanical problems. In particular, in this course we will focus on
  * Quantum Monte Carlo methods applied to few-electron systems like "quantum dots":"https://journals.aps.org/rmp/abstract/10.1103/RevModPhys.74.1283", electrons confined to move in two or three dimensions. The system we will study will contain up to 20 interacting electrons in an oscillator trap. 
  * Linear algebra and eigenvalue problems with applications to the same physical systems, simple two-electron systems and Hartree-Fock theory.
  * Object orientation, code optimization and High-performance computing aspects 
The main programming language will be c++, interspersed with Python examples in the slides.
!eblock




!split
===== Overarching aims of this course =====
!bblock
While developing the mathematical tools and a numerical project we aim at giving you an
insight in how to:
  * Develop a critical approach to all steps in a project, which methods are most relevant, which natural laws and physical processes are important. Sort out initial conditions and boundary conditions etc.
  * To teach you structured scientific computing and learn to structure a project using for example object orientation.
  * To give you a critical understanding of central mathematical algorithms and methods from numerical analysis. In particular their limits and stability criteria.
  * To show you how to use version control software to keep track of different versions of your normal project, how to verify and validate your codes and how to make your science reproducible. 
!eblock




!split
===== Learning outcomes =====
!bblock 
We hope we can give you some useful hints and guidance on
 * how to develop a thorough understanding of how computing is used to solve scientific problems
 * getting to know some central  algorithms used in science
 * developing knowledge of high-performance computing elements: memory usage, vectorization and parallel algorithms
 * understanding approximation errors and what can go wrong with algorithms
 * getting experience with programming in a compiled language (Fortran, C, C++)
 * getting experience with test frameworks and procedures
 * being able to  critically evaluate results and errors
 * understanding how to increase the efficiency of numerical algorithms and pertinent software
 * understanding tools to make science reproducible and to develop a sound ethical approach to scientific problems
!eblock




    
!split
===== Why is computing comptence important? =====
!bblock   Definition of computing    
With computing I will mean solving scientific problems using computers. It covers numerical, analytical as well as symbolic computing. Computing is also about developing an understanding of the scientific process by enhancing algorithmic thinking when solving problems.
!eblock


!split
===== Computing competence, what is it? =====
!bblock 
Computing competence has always been a central part of the science and engineering education. Traditionally, such competence meant mastering mathematical methods to solve science problems - by pen and paper. 

Today you are expected to use all available tools to solve scientific problems; computers primarily, but also pen and paper. 

I will use the term/word algorithms in the broad meaning:  methods (for example mathematical) to solve science problems, with and without computers.
!eblock



!split
===== What is computing competence about?  =====
!bblock   
Computing competence is about

o derivation, verification, and implementation of algorithms
o understanding what can go wrong with algorithms
o overview of important, known algorithms
o understanding how algorithms are used to solve mathematical problems
o reproducible science and ethics
o algorithmic thinking for gaining deeper insights about scientific problems
!eblock


!split
===== Continuous verse discrete =====
!bblock  
Algorithms involving pen and paper are traditionally aimed at what we often refer to as continuous models. 

Application of computers calls for approximate discrete models. 

Much of the development of methods for continuous models are now being replaced by methods for discrete models in science and industry, simply because much larger problem classes can be addressed with discrete models, often also by simpler and more generic methodologies. However, verification of algorithms and understanding their limitations requires much of the classical knowledge about continuous models.
!eblock



!split
===== Shift from classical mathematics to modern computing? =====
!bblock  
o The impact of the computer on mathematics is tremendous: science and industry now rely on solving mathematical problems through computing.
o Computing increases the relevance in education by solving more realistic problems earlier.
o Computing through programming is excellent training of creativity.
o Computing enhances the understanding of abstractions and generalization.
o Computing decreases the need for special tricks and tedious algebra, and shifts the focus to problem definition, visualization, and "what if" discussions.

The result is a deeper understanding of mathematical modeling. Not only is computing via programming a very powerful tool, it also a great pedagogical aid.
For the mathematical training, there is one major new component among the arguments above: understanding abstractions and generalization. While many of the classical methods developed for continuous models are specialized for a particular problem or a narrow class of problems, computing-based algorithms are often developed for problems in a generic form and hence applicable to a large problem class.
!eblock



!split
===== Key principle in scientific modeling =====
!bblock
The power of the scientific method lies in identifying a given problem as a special case of an abstract class of problems, identifying general solution methods for this class of problems, and applying a general method to the specific problem (applying means, in the case of computing, calculations by pen and paper, symbolic computing, or numerical computing by ready-made and/or self-written software). This generic view on problems and methods is particularly important for understanding how to apply available, generic software to solve a particular problem.
!eblock


!split
===== Computing competence is central to solving scientific problems =====
!bblock   Definition of computing    
Computing competence represents a central element in scientific problem solving, from basic education and research to essentially almost all advanced problems in modern societies. Computing competence is simply central to further progress. It enlarges the body of tools available to students and scientists beyond classical tools and allows for a more generic handling of problems. Focusing on algorithmic aspects results in deeper insights about scientific problems.

Today's project in science and industry tend to involve larger teams. Tools for reliable collaboration must therefore be mastered (e.g., version control systems, automated computer experiments for reproducibility, software and method documentation).

!eblock


!split
===== Modeling and computations =====
!bblock 
In this course we will try to focus on how to 

* Introduce Research based teaching  from day one
* Trigger further insights in math and other disciplines 
* Validation and verification of scientific results, with the possibility to emphasize ethical aspects as well. Version control is central.
* Introduce good project handling  practices from day one.
!eblock




!split
===== Symbolic calculations and numerical calculations in one code  =====
!bblock 
The following simple example here illustrates many of the previous points. 
Python offers an  extremely versatile programming  environment, allowing for
the inclusion of analytical studies in a numerical program. Here we show an
example code with the _trapezoidal rule_ using _SymPy_ to evaluate an integral and compute the absolute error
with respect to the numerically evaluated one of the integral
$4\int_0^1 dx/(1+x^2) = \pi$:
!bc pyscpro
from math import *
from sympy import *
def Trapez(a,b,f,n):
   h = (b-a)/float(n)
   s = 0
   x = a
   for i in range(1,n,1):
       x = x+h
       s = s+ f(x)
   s = 0.5*(f(a)+f(b)) +s
   return h*s

#  function to compute pi
def function(x):
    return 4.0/(1+x*x)

a = 0.0;  b = 1.0; n = 100
result = Trapez(a,b,function,n)
print "Trapezoidal rule=", result
# define x as a symbol to be used by sympy
x = Symbol('x')
exact = integrate(function(x), (x, 0.0, 1.0))
print "Sympy integration=", exact
# Find relative error
print "Relative error", abs((exact-result)/exact)
!ec
!eblock




!split
===== Error analysis =====
!bblock 
The following extended version of the trapezoidal rule allows you  to plot the relative error by comparing with the exact result. By increasing to $10^8$ points one arrives at a region where numerical errors start to accumulate.
!bc pyscpro
from math import log10
import numpy as np
from sympy import Symbol, integrate
import matplotlib.pyplot as plt
# function for the trapezoidal rule
def Trapez(a,b,f,n):
   h = (b-a)/float(n)
   s = 0
   x = a
   for i in range(1,n,1):
       x = x+h
       s = s+ f(x)
   s = 0.5*(f(a)+f(b)) +s
   return h*s
#  function to compute pi
def function(x):
    return 4.0/(1+x*x)
# define integration limits
a = 0.0;  b = 1.0;
# find result from sympy
# define x as a symbol to be used by sympy
x = Symbol('x')
exact = integrate(function(x), (x, a, b))
# set up the arrays for plotting the relative error
n = np.zeros(9); y = np.zeros(9);
# find the relative error as function of integration points
for i in range(1, 8, 1):
    npts = 10**i
    result = Trapez(a,b,function,npts)
    RelativeError = abs((exact-result)/exact)
    n[i] = log10(npts); y[i] = log10(RelativeError);
plt.plot(n,y, 'ro')
plt.xlabel('n')
plt.ylabel('Relative error')
plt.show()
!ec
!eblock


!split
===== Integrating numerical mathematics with calculus =====
!bblock 
The last example shows the potential of combining numerical algorithms with symbolic calculations, allowing you thereby  to
* Validate and verify  your  algorithms. 
* Include concepts like unit testing. It gives you the possibility to test and validate several or all parts of the code.
* Validation and verification are then included *naturally* and you can develop a better attitude to what is meant with an ethically sound scientific approach.
* The above example allows you to test the mathematical error of the algorithm for the trapezoidal rule by changing the number of integration points. You get to think error analysis from day one.

!eblock



!split
===== Additional benefits: A structured approach to solving problems =====
!bblock 
In this process we easily bake in
 o   How to structure a code in terms of functions
 o   How to make a module
 o   How to read input data flexibly from the command line
 o   How to create graphical/web user interfaces
 o   How to write unit tests (test functions or doctests)
 o   How to refactor code in terms of classes (instead of functions only)
 o   How to conduct and automate large-scale numerical experiments
 o   How to write scientific reports in various formats (LaTeX, HTML)
!eblock


!split
===== Additional benefits: A structure approach to solving problems =====
!bblock 
The conventions and techniques outlined here will save you a lot of time when you incrementally extend software over time from simpler to more complicated problems. In particular, you will benefit from many good habits:
 o New code is added in a modular fashion to a library (modules)
 o Programs are run through convenient user interfaces
 o It takes one quick command to let all your code undergo heavy testing 
 o Tedious manual work with running programs is automated,
 o Your scientific investigations are reproducible, scientific reports with top quality typesetting are produced both for paper and electronic devices.
!eblock





